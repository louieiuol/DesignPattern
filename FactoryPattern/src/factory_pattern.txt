工厂模式

意图
1. 定义一个创建对象的接口, 让其子类自己决定实例化哪一个工厂类, 工厂模式使其创建过程延迟到子类

主要解决 
1. 主要解决接口选择类问题

何时使用 
1. 我们明确计划不同条件下创建不同实例时

关键代码
创建过程在子类执行

如何解决
1. 让其子类实现工厂接口, 返回的也是一个抽象的产品

优点
1. 调用者想创建一个对象, 只知道其名称就可以了
2. 扩展性高, 如果想增加一个产品, 只需扩展一个工厂类就可以了
3. 屏蔽产品具体实现, 调用者只关心产品的接口

缺点 
1. 每次增加一个产品时, 都需要增加一个具体类和对象实现工厂, 使得系统中类的个数成倍增加, 在一定程度上增加了系统的复杂性

使用场景
1. 日志记录器: 记录可能记录到本地硬盘, 系统事件, 远程服务器
2. 数据库访问: 当用户不知道最后系统采用哪一类的数据库, 以及数据库可能有变化时
3. 设计一个连接服务器的框架, 需要3个协议, "POP", "IMAP", "HTTP",可以把这3个作为产品类, 共同实现一个接口

实现

Shape接口, Shape接口实体类, 下一步是定义工厂类ShapeFactory

FactoryPatternDemo类使用ShapeFactory来获取 Shape对象, 它向ShapeFactory传递信息(CIRCLE/RECTANGLE/SQUARE), 以便获取它所需的对象类型


										<<interface>>
											Shape					<-------------------------------    ShapeFactory
										+draw(): void							创建工厂                 +getShape(): Shape
											|																|
		 ----------------------------------------------------------------------------						|
		|								    |										|						|
		|  implements					 	|	implements							| implements			|
	Circle 								  Square								Rectangle			FactoryPatternDemo
+draw():void							+draw(): void						  +draw(): void				+main():void



