状态模式(State Pattern)中, 类的行为是基于它的状态改变的. 这种类型的设计模式属于行为型模式
在状态模式中, 我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context的对象

介绍
意图:
允许对象在内部状态发生改变时候改变它的行为, 对象看起来好像修改了它的类

主要解决:
对象的行为依赖与它的状态, 并且可以根据状态改变而改变行为

何时使用:
代码中包含大量与对象状态有关的条件语句

关键代码:
通常命令模式的接口中只有一个方法, 而状态模式的接口中有一个或多个方法. 而且状态模式的实现类的方法,
一般返回值,或者是改变实例变量的值.也就是说, 状态模式一般和对象的状态有关. 实现类的方法有不同的功能
, 覆盖接口中的方法. 状态模式和命令模式一样, 可以用于消除if...else语句

优点:
1. 封装了转换规则
2. 枚举可能的状态, 在枚举状态之前需要确定状态种类
3. 将所有与某个状态有关的行为放到一个类中, 并且可以方便的增加新的状态, 只需要改变对象状态即可改变对象行为
4. 允许状态转换逻辑与状态对象合成一体
5. 可以让对个环境对象共享一个状态对象, 从而减少系统对象的个数

缺点:
1. 状态模式的使用必然会增加系统类和对象的个数
2. 状态模式的结构和实现复杂
3. 开闭原则不友好

使用场景:
1. 行为随着状态改变而改变的场景
2. 条件, 分支语句代替者

注意:
行为受状态约束的时候使用状态模式, 而且状态不超过5个


实现:
我们将创建一个State接口和实现了State接口的实体状态类
Context是一个带有某个状态的类
StatePatternDemo, 我们演示类使用Context和状态对象来演示Context在状态改变时的行为变化

		
			<<interface>>						uses			Context						|   	asks
				State					<-----------------  	-state: State				|	<------------  StatePatternDemo
			+doAction(): void									+Context(): void			|					+main(): void
				|												+getState(): state
				|												+setState(): void
				|
-------------------------------------
|									|
|									|
|implements							| implements
|									|
|									|
StartState						StopState
+doAction(): void				+doAction():void